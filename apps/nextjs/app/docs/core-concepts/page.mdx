# Core Concepts

DDD patterns from `@packages/ddd-kit`.

## Overview

**Result** - Explicit errors, no exceptions

**Option** - No null, explicit absence

**Value Objects** - Immutable validated concepts (Email, Money)

**Entities** - Objects with identity (User, Order)

**Aggregates** - Consistency boundaries + events

---

## Result

Replace `try/catch` with explicit error handling.

```typescript
// Bad: Throws - implicit
function parseAge(input: string): number {
  if (isNaN(parseInt(input))) throw new Error('Invalid')
  return parseInt(input)
}

// Good: Result - explicit
function parseAge(input: string): Result<number> {
  const age = parseInt(input)
  if (isNaN(age)) return Result.fail('Invalid age')
  return Result.ok(age)
}

// Usage
const result = parseAge(input)
if (result.isFailure) return handleError(result.error)
const age = result.value // Type-safe
```

[Learn more](/docs/core-concepts/result)

---

## Option

Eliminate `null` and `undefined`.

```typescript
// Bad: Null - dangerous
const user = await findUser(id) // User | null
console.log(user.email) // Can crash!

// Good: Option - safe
const userOption = await findUser(id) // Result<Option<User>>
match(userOption.value, {
  Some: (user) => console.log(user.email),
  None: () => console.log('Not found')
})
```

[Learn more](/docs/core-concepts/option)

---

## Value Objects

Immutable, validated business concepts.

```typescript
export class Email extends ValueObject<{ value: string }> {
  protected validate(props): Result<typeof props> {
    if (!EMAIL_REGEX.test(props.value)) {
      return Result.fail('Invalid email format')
    }
    return Result.ok({ value: props.value.toLowerCase() })
  }
}

// Usage
const email = Email.create({ value: 'USER@EXAMPLE.COM' })
if (email.isSuccess) {
  console.log(email.value.value) // "user@example.com"
}
```

[Learn more](/docs/core-concepts/value-objects)

---

## Entities

Objects with unique identity.

```typescript
export class User extends Entity<UserProps> {
  static create(props: { email: Email; name: string }): Result<User> {
    if (!props.name) return Result.fail('Name required')
    return Result.ok(new User(props, UUID.create()))
  }

  updateName(name: string): Result<User> {
    return Result.ok(this.clone({ name })) // Returns NEW instance
  }

  canPlaceOrder(): boolean {
    return this.get('isActive') && !this.get('isBanned')
  }
}

// Comparison by ID
user1.equals(user2) // true if same ID
```

[Learn more](/docs/core-concepts/entities)

---

## Quick Rules

**Do:**
- Return Result in Domain/Application
- Use Option for queries
- Freeze Value Objects
- Create via static factory methods

**Avoid:**
- Throwing exceptions in Domain/Application
- Returning null or undefined
- Mutating domain objects
- Public constructors

## Next Steps

- [Result Pattern](/docs/core-concepts/result)
- [Option Pattern](/docs/core-concepts/option)
- [Value Objects](/docs/core-concepts/value-objects)
- [Entities](/docs/core-concepts/entities)
