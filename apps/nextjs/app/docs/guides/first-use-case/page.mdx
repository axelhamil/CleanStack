# First Use Case

Create a Product feature with Clean Architecture.

## Overview

We'll build:
- **Domain**: `ProductName` (VO), `Product` (Entity)
- **Application**: `IProductRepository`, `CreateProductUseCase`
- **Adapters**: Schema, Repository, API Route, DI

## 1. Value Object

```typescript
// domain/product/ProductName.ts
import { Result, ValueObject } from '@packages/ddd-kit'

interface ProductNameProps { value: string }

export class ProductName extends ValueObject<ProductNameProps> {
  protected validate(props: ProductNameProps): Result<ProductNameProps> {
    const trimmed = props.value.trim()
    if (!trimmed) return Result.fail('Name required')
    if (trimmed.length > 100) return Result.fail('Name too long')
    return Result.ok({ value: trimmed })
  }
}
```

## 2. Entity

```typescript
// domain/product/Product.ts
import { Entity, Result, UUID } from '@packages/ddd-kit'
import type { ProductName } from './ProductName'

interface ProductProps {
  name: ProductName
  price: number
  createdAt: Date
}

export class Product extends Entity<ProductProps> {
  private constructor(props: ProductProps, id?: UUID) {
    super(props, id)
  }

  static create(props: { name: ProductName; price: number }): Result<Product> {
    if (props.price < 0) return Result.fail('Price cannot be negative')
    return Result.ok(new Product({
      name: props.name,
      price: props.price,
      createdAt: new Date()
    }, UUID.create()))
  }
}
```

## 3. Repository Interface

```typescript
// application/ports/IProductRepository.ts
import type { BaseRepository } from '@packages/ddd-kit'
import type { Product } from '@/domain/product/Product'

export interface IProductRepository extends BaseRepository<Product> {}
```

## 4. Use Case

```typescript
// application/use-cases/CreateProductUseCase.ts
import { Result, type UseCase } from '@packages/ddd-kit'
import { Product } from '@/domain/product/Product'
import { ProductName } from '@/domain/product/ProductName'
import type { IProductRepository } from '@/application/ports/IProductRepository'
import type { Transaction } from 'drizzle-orm/node-postgres'

interface CreateProductInput { name: string; price: number }

export class CreateProductUseCase implements UseCase<CreateProductInput, Product> {
  constructor(private readonly productRepo: IProductRepository) {}

  async execute(input: CreateProductInput, trx?: Transaction): Promise<Result<Product>> {
    const nameOrError = ProductName.create({ value: input.name })
    if (nameOrError.isFailure) return Result.fail(nameOrError.error)

    const productOrError = Product.create({
      name: nameOrError.value,
      price: input.price
    })
    if (productOrError.isFailure) return Result.fail(productOrError.error)

    return await this.productRepo.create(productOrError.value, trx)
  }
}
```

## 5. Database Schema

```typescript
// packages/drizzle/src/schema/products.ts
import { pgTable, text, real, uuid, timestamp } from 'drizzle-orm/pg-core'

export const products = pgTable('products', {
  id: uuid('id').primaryKey(),
  name: text('name').notNull(),
  price: real('price').notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow()
})
```

```bash
pnpm db:generate && pnpm db:push
```

## 6. Repository Implementation

```typescript
// adapters/out/persistence/DrizzleProductRepository.ts
import { Result, Option, DatabaseOperationError, type UUID } from '@packages/ddd-kit'
import { db } from '@packages/drizzle'
import { products } from '@packages/drizzle/schema'
import { eq } from 'drizzle-orm'
import type { Transaction } from 'drizzle-orm/node-postgres'
import type { IProductRepository } from '@/application/ports/IProductRepository'
import type { Product } from '@/domain/product/Product'
import { ProductMapper } from './mappers/ProductMapper'

export class DrizzleProductRepository implements IProductRepository {
  async create(product: Product, trx?: Transaction): Promise<Result<Product>> {
    try {
      const database = trx ?? db
      await database.insert(products).values(ProductMapper.toPersistence(product))
      return Result.ok(product)
    } catch (error) {
      return Result.fail(new DatabaseOperationError('Failed to create product'))
    }
  }

  async findById(id: UUID, trx?: Transaction): Promise<Result<Option<Product>>> {
    const database = trx ?? db
    const row = await database.query.products.findFirst({ where: eq(products.id, id.value) })
    if (!row) return Result.ok(Option.none())
    return Result.ok(Option.some(ProductMapper.toDomain(row).value))
  }

  // Implement other BaseRepository methods...
}
```

## 7. DI Registration

```typescript
// common/di/modules/product.module.ts
import type { ApplicationContainer } from '@evyweb/ioctopus'
import { DrizzleProductRepository } from '@/adapters/out/persistence/DrizzleProductRepository'
import { CreateProductUseCase } from '@/application/use-cases/CreateProductUseCase'

export const productModule = (container: ApplicationContainer) => {
  container.bind('IProductRepository').toClass(DrizzleProductRepository)
  container.bind('CreateProductUseCase').toClass(CreateProductUseCase)
}
```

## 8. API Route

```typescript
// app/api/products/route.ts
import { getInjection } from '@/common/di/container'
import { z } from 'zod'

const schema = z.object({
  name: z.string().min(1).max(100),
  price: z.number().min(0)
})

export async function POST(request: Request) {
  const body = await request.json()
  const validation = schema.safeParse(body)
  if (!validation.success) {
    return Response.json({ error: validation.error }, { status: 400 })
  }

  const useCase = getInjection('CreateProductUseCase')
  const result = await useCase.execute(validation.data)

  if (result.isFailure) {
    return Response.json({ error: result.error }, { status: 400 })
  }

  return Response.json({
    id: result.value._id.value,
    name: result.value.get('name').value.value,
    price: result.value.get('price')
  }, { status: 201 })
}
```

## Test

```bash
curl -X POST http://localhost:3000/api/products \
  -H "Content-Type: application/json" \
  -d '{"name": "MacBook Pro", "price": 2499}'
```

## Summary

**Domain:** ProductName.ts, Product.ts

**Application:** IProductRepository.ts, CreateProductUseCase.ts

**Adapters:** schema/products.ts, DrizzleProductRepository.ts, route.ts

**Infrastructure:** product.module.ts

## Next Steps

- [Transactions](/docs/guides/transactions)
- [Testing](/docs/guides/testing)
