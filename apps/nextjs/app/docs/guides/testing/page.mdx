# Testing

Clean Architecture makes testing easy.

## Testing Pyramid

```
       /\        E2E (10%) - Slow, via API
      /  \
     /----\      Integration (30%) - Use Cases + DB
    /      \
   /--------\    Unit (60%) - Domain, fast
```

## Unit Tests (Domain)

No mocks needed - pure business logic.

```typescript
// domain/product/__TESTS__/ProductName.test.ts
describe('ProductName', () => {
  it('creates valid name', () => {
    const result = ProductName.create({ value: 'iPhone' })
    expect(result.isSuccess).toBe(true)
  })

  it('rejects empty name', () => {
    const result = ProductName.create({ value: '' })
    expect(result.isFailure).toBe(true)
  })

  it('trims whitespace', () => {
    const result = ProductName.create({ value: '  iPhone  ' })
    expect(result.value.value.value).toBe('iPhone')
  })
})
```

## Integration Tests (Use Cases)

Mock repositories.

```typescript
// application/use-cases/__TESTS__/CreateUserUseCase.test.ts
describe('CreateUserUseCase', () => {
  const mockRepo = {
    create: vi.fn(),
    findByEmail: vi.fn()
  }

  it('creates user successfully', async () => {
    mockRepo.findByEmail.mockResolvedValue(Result.ok(Option.none()))
    mockRepo.create.mockResolvedValue(Result.ok(mockUser))

    const useCase = new CreateUserUseCase(mockRepo)
    const result = await useCase.execute({ email: 'test@example.com', name: 'Alice' })

    expect(result.isSuccess).toBe(true)
    expect(mockRepo.create).toHaveBeenCalledOnce()
  })

  it('fails if email exists', async () => {
    mockRepo.findByEmail.mockResolvedValue(Result.ok(Option.some(existingUser)))

    const result = await useCase.execute({ email: 'test@example.com', name: 'Alice' })

    expect(result.isFailure).toBe(true)
    expect(mockRepo.create).not.toHaveBeenCalled()
  })
})
```

## E2E Tests (Routes)

Real database.

```typescript
// adapters/in/api/__TESTS__/users.test.ts
describe('POST /api/users', () => {
  beforeEach(async () => {
    await db.delete(users)
  })

  it('creates user and returns 201', async () => {
    const response = await POST(new Request('http://localhost/api/users', {
      method: 'POST',
      body: JSON.stringify({ email: 'test@example.com', name: 'Alice' })
    }))

    expect(response.status).toBe(201)
    const rows = await db.select().from(users)
    expect(rows).toHaveLength(1)
  })

  it('returns 400 for invalid email', async () => {
    const response = await POST(new Request('http://localhost/api/users', {
      method: 'POST',
      body: JSON.stringify({ email: 'invalid', name: 'Alice' })
    }))

    expect(response.status).toBe(400)
  })
})
```

## Commands

```bash
pnpm test              # All tests
pnpm test:watch        # Watch mode
pnpm test:coverage     # Coverage report
```

## Best Practices

### ✅ Do

```typescript
// Test behavior
it('rejects invalid email', () => {
  expect(Email.create('invalid').isFailure).toBe(true)
})

// AAA pattern
it('creates user', async () => {
  // Arrange
  const mockRepo = createMockRepo()

  // Act
  const result = await useCase.execute(input)

  // Assert
  expect(result.isSuccess).toBe(true)
})

// Descriptive names
it('should reject email longer than 255 characters', () => {})
```

### ❌ Don't

```typescript
// Test implementation
expect(spy).toHaveBeenCalled()

// Dependent tests
let user: User
it('creates user', () => { user = ... })
it('updates user', () => { user.update(...) })  // Depends on previous!
```

## Next Steps

- [First Use Case](/docs/guides/first-use-case)
- [Transactions](/docs/guides/transactions)
