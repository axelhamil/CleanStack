# Domain Events

Implement event-driven architecture with type-safe domain events.

## Overview

Domain Events capture important changes in your domain. CleanStack provides:

- **BaseDomainEvent** - Type-safe event base class
- **IEventDispatcher** - Pub/sub interface
- **Event Handlers** - React to events asynchronously

## Creating Events

Events live in `domain/[context]/events/`:

```typescript
// domain/user/events/user-created.event.ts
import { BaseDomainEvent } from "@packages/ddd-kit";

interface UserCreatedPayload {
  userId: string;
  email: string;
  name: string;
}

export class UserCreatedEvent extends BaseDomainEvent<UserCreatedPayload> {
  readonly eventType = "user.created";
  readonly aggregateId: string;
  readonly payload: UserCreatedPayload;

  constructor(userId: string, email: string, name: string) {
    super();
    this.aggregateId = userId;
    this.payload = { userId, email, name };
  }
}
```

## Emitting Events

Aggregates emit events via `addEvent()`:

```typescript
// domain/user/user.aggregate.ts
export class User extends Aggregate<IUserProps> {
  static create(props: CreateUserProps, id?: UUID): User {
    const user = new User({ ...props, createdAt: new Date() }, id ?? new UUID());

    // Emit domain event
    user.addEvent(
      new UserCreatedEvent(
        user.id.value,
        props.email.value,
        props.name.value
      )
    );

    return user;
  }
}
```

## Event Dispatcher

The `IEventDispatcher` port handles event distribution:

```typescript
// application/ports/event-dispatcher.port.ts
export interface IEventDispatcher {
  subscribe<T extends IDomainEvent>(
    eventType: string,
    handler: EventHandler<T>
  ): Result<void>;

  dispatch(event: IDomainEvent): Promise<Result<void>>;
  dispatchAll(events: IDomainEvent[]): Promise<Result<void>>;
}
```

## Creating Handlers

Event handlers react to events:

```typescript
// application/event-handlers/send-welcome-email.handler.ts
import type { EventHandler } from "../ports/event-dispatcher.port";
import type { UserCreatedEvent } from "@/domain/user/events/user-created.event";

export const createSendWelcomeEmailHandler = (
  emailService: IEmailService
): EventHandler<UserCreatedEvent> => {
  return async (event) => {
    const result = await emailService.sendWelcomeEmail(
      event.payload.email,
      event.payload.name
    );
    return result;
  };
};
```

## Registering Handlers

Register handlers in the DI module:

```typescript
// common/di/modules/events.module.ts
export const createEventsModule = () => {
  const m = createModule();

  m.bind(DI_SYMBOLS.IEventDispatcher)
    .toFactory(() => {
      const dispatcher = new InMemoryEventDispatcher();
      const emailService = getInjection("IEmailService");

      // Subscribe handlers
      dispatcher.subscribe(
        "user.created",
        createSendWelcomeEmailHandler(emailService)
      );

      return dispatcher;
    });

  return m;
};
```

## Dispatching in Use Cases

Dispatch events after successful persistence:

```typescript
// application/use-cases/auth/sign-up.use-case.ts
async execute(input: Input): Promise<Result<Output>> {
  const user = User.create({ email, name, password });

  const saveResult = await this.userRepo.create(user);
  if (saveResult.isFailure) return Result.fail(saveResult.getError());

  // Dispatch domain events
  await this.eventDispatcher.dispatchAll(user.domainEvents);
  user.clearEvents();

  return Result.ok(this.toDto(user));
}
```

## Available Events

### User Events
| Event | Trigger |
|-------|---------|
| `user.created` | New user registration |
| `user.verified` | Email verification |
| `user.signed_in` | Successful login |

### Billing Events
| Event | Trigger |
|-------|---------|
| `subscription.created` | New subscription |
| `subscription.cancelled` | Cancellation |
| `subscription.renewed` | Auto-renewal |
| `plan.changed` | Plan upgrade/downgrade |
| `payment.failed` | Payment failure |

## Testing Events

```typescript
describe("UserCreatedEvent", () => {
  it("should create event with correct payload", () => {
    const event = new UserCreatedEvent("123", "test@example.com", "John");

    expect(event.eventType).toBe("user.created");
    expect(event.aggregateId).toBe("123");
    expect(event.payload.email).toBe("test@example.com");
  });
});
```

## Best Practices

1. **Name events in past tense** - `UserCreated`, not `CreateUser`
2. **Include only necessary data** - Don't include entire aggregates
3. **Events are immutable** - Never modify after creation
4. **Handle failures gracefully** - Events shouldn't break the main flow

## Next Steps

- [Authentication Guide](/docs/guides/authentication)
- [Billing Guide](/docs/guides/billing)
- [Testing Strategy](/docs/guides/testing)
