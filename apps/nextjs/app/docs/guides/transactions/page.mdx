# Transactions

Atomicity for multi-step operations.

## The Problem

```typescript
// ❌ Without transaction - inconsistent state possible
const userResult = await createUserUseCase.execute(body)
if (userResult.isFailure) return // User not created

const emailResult = await sendEmailUseCase.execute({ userId: userResult.value.id })
if (emailResult.isFailure) return // User created but email failed!
```

## The Solution

```typescript
// ✅ With transaction - all or nothing
const result = await txManager.execute(async (trx) => {
  const userResult = await createUserUseCase.execute(body, trx)
  if (userResult.isFailure) return Result.fail(userResult.error) // Rollback

  const emailResult = await sendEmailUseCase.execute({ userId: userResult.value.id }, trx)
  if (emailResult.isFailure) return Result.fail(emailResult.error) // Rollback

  return Result.ok(userResult.value) // Commit
})
```

## Architecture

**Controller manages transaction, Use Case executes with `trx`.**

```
Controller
├─ Gets TransactionManager from DI
├─ Starts transaction
├─ Calls Use Cases with trx
└─ Auto-commit/rollback

Use Case
├─ Receives trx?: Transaction
└─ Passes trx to Repository

Repository
├─ const db = trx ?? defaultDb
└─ Uses db for queries
```

## Implementation

### Route Handler

```typescript
export async function POST(request: Request) {
  const txManager = getInjection('ITransactionManagerService')
  const createUserUseCase = getInjection('CreateUserUseCase')
  const createProfileUseCase = getInjection('CreateProfileUseCase')

  const body = await request.json()

  const result = await txManager.execute(async (trx) => {
    const userResult = await createUserUseCase.execute(body, trx)
    if (userResult.isFailure) return Result.fail(userResult.error)

    const profileResult = await createProfileUseCase.execute(
      { userId: userResult.value.id },
      trx
    )
    if (profileResult.isFailure) return Result.fail(profileResult.error)

    return Result.ok(userResult.value)
  })

  if (result.isFailure) return Response.json({ error: result.error }, { status: 400 })
  return Response.json(result.value, { status: 201 })
}
```

### Use Case

```typescript
export class CreateUserUseCase implements UseCase<Input, User> {
  constructor(private readonly userRepo: IUserRepository) {}

  async execute(input: Input, trx?: Transaction): Promise<Result<User>> {
    const userOrError = User.create(input)
    if (userOrError.isFailure) return Result.fail(userOrError.error)

    return await this.userRepo.create(userOrError.value, trx)
  }
}
```

### Repository

```typescript
export class DrizzleUserRepository implements IUserRepository {
  async create(user: User, trx?: Transaction): Promise<Result<User>> {
    const database = trx ?? db  // Use transaction if provided
    await database.insert(users).values(UserMapper.toPersistence(user))
    return Result.ok(user)
  }
}
```

## Rules

### ✅ Do

```typescript
// Controller manages transaction
await txManager.execute(async (trx) => {
  await useCase1.execute(input1, trx)
  await useCase2.execute(input2, trx)
})

// Pass trx to all repos
async execute(input, trx?: Transaction) {
  return await this.repo.create(entity, trx)
}

// Use trx if provided
const database = trx ?? db
```

### ❌ Don't

```typescript
// Use Case managing transaction
class CreateUserUseCase {
  async execute(input) {
    return await this.txManager.execute(async (trx) => {
      // Can't compose with other Use Cases!
    })
  }
}

// Forgetting to pass trx
await this.repo.create(user)  // Uses default db, not trx!
```

## Next Steps

- [Testing](/docs/guides/testing)
- [First Use Case](/docs/guides/first-use-case)
