# AI Agents

Specialized autonomous assistants for architecture, review, testing, and documentation.

## Overview

Agents are Claude Code configurations that define specialized behaviors and tool access for specific tasks. Unlike skills (interactive workflows), agents:

- **Work autonomously** - Complete tasks with minimal guidance
- **Have specific tools** - Access only what they need
- **Follow defined processes** - Consistent methodology
- **Produce structured output** - Predictable formats

## Available Agents

| Agent | Purpose | Tools |
|-------|---------|-------|
| Feature Architect | Design feature implementation | Read, Glob, Grep |
| Code Reviewer | Review code for issues | Read, Glob, Grep |
| Test Writer | Generate comprehensive tests | Read, Glob, Write |
| Doc Writer | Maintain documentation | Read, Glob, Grep, Write, Edit |

## Feature Architect

Designs feature implementations following Clean Architecture patterns.

### When to Use

- Planning a new feature
- Designing aggregate structure
- Mapping domain to implementation files

### Process

1. Analyze requirements (PRD or description)
2. Identify aggregates, VOs, events
3. Map to file structure
4. Define dependencies
5. Create implementation plan

### Output

```markdown
## Feature Architecture: Subscription Management

### Domain Layer
- `src/domain/subscription/subscription.aggregate.ts`
- `src/domain/subscription/subscription.id.ts`
- `src/domain/subscription/value-objects/subscription-status.vo.ts`
- `src/domain/subscription/events/subscription-created.event.ts`

### Application Layer
- `src/application/ports/subscription.repository.port.ts`
- `src/application/use-cases/subscription/create-subscription.use-case.ts`
- `src/application/dto/subscription/create-subscription.dto.ts`

### Adapters Layer
- `src/adapters/repositories/drizzle-subscription.repository.ts`
- `src/adapters/mappers/subscription.mapper.ts`

### Infrastructure
- `packages/drizzle/schema/subscription.ts`
- `common/di/modules/subscription.module.ts`

### Implementation Order
1. Domain layer (aggregate, VOs, events)
2. Application layer (ports, DTOs, use cases)
3. Adapters (repository, mapper)
4. Infrastructure (schema, DI)
5. Tests
```

## Code Reviewer

Reviews code for bugs, architecture violations, and DDD compliance.

### When to Use

- Before committing changes
- Reviewing pull requests
- Auditing existing code

### Review Checklist

#### Architecture (Clean Architecture)

| Check | Rule |
|-------|------|
| Domain isolation | Domain imports only `@packages/ddd-kit`, `zod` |
| Dependency direction | Use cases don't import from adapters |
| Controller simplicity | Controllers orchestrate, no business logic |
| Port abstraction | Use cases depend on interfaces |

#### DDD Patterns

| Check | Rule |
|-------|------|
| Result usage | Fallible operations return `Result<T>` |
| Option usage | Nullable values use `Option<T>` |
| VO validation | Validation in static `create()` method |
| Event emission | Events in aggregate methods, not constructors |
| Event dispatch | Events dispatched after persistence |

#### Code Quality

| Check | Rule |
|-------|------|
| No any | Avoid `any` type |
| No unused | No unused imports/variables |
| No console | No `console.log` in production |
| No hardcoded | No magic strings/numbers |

### Output Format

```markdown
**[ERROR]** Architecture: Domain imports infrastructure

- **File:** `src/domain/user/user.aggregate.ts:5`
- **Issue:** Imports `db` from `@/common/db`
- **Fix:** Remove import, use repository port instead
- **Confidence:** High

## Review Summary

### Issues by Severity
- CRITICAL: 0
- ERROR: 2
- WARNING: 3
- INFO: 1

### Top 3 Priorities
1. Fix domain layer import violation
2. Add Result return type to updateStatus method
3. Replace Option with null check

### Overall Assessment
Needs work - Architecture violations must be fixed
```

### Severity Levels

| Level | Description | Action |
|-------|-------------|--------|
| CRITICAL | Security, data loss, crashes | Must fix before merge |
| ERROR | Bugs, architecture violations | Should fix before merge |
| WARNING | Code smell, inconsistencies | Consider fixing |
| INFO | Suggestions, minor improvements | Nice to have |

## Test Writer

Writes comprehensive BDD-style tests with thorough coverage.

### When to Use

- After implementing code
- When tests are missing
- Improving test coverage

### Test Categories

1. **Happy Path** - Valid input produces expected output
2. **Validation Errors** - Each validation rule that can fail
3. **Business Rules** - Each rule that can be violated
4. **Edge Cases** - Empty values, boundaries
5. **Error Handling** - Repository/provider failures
6. **Event Emission** - Domain events verification

### Generated Test Structure

```typescript
describe("CreateSubscriptionUseCase", () => {
  let sut: CreateSubscriptionUseCase;
  let mockRepo: ISubscriptionRepository;
  let mockEventDispatcher: IEventDispatcher;

  const validInput = {
    userId: "user-123",
    planId: "plan-pro",
  };

  beforeEach(() => {
    vi.clearAllMocks();
    mockRepo = {
      create: vi.fn(),
      findById: vi.fn(),
      // ... other methods
    };
    mockEventDispatcher = {
      dispatch: vi.fn(),
      dispatchAll: vi.fn(),
    };
    sut = new CreateSubscriptionUseCase(mockRepo, mockEventDispatcher);
  });

  describe("happy path", () => {
    it("should create subscription when input is valid", async () => {
      vi.mocked(mockRepo.create).mockResolvedValue(Result.ok(mockEntity));

      const result = await sut.execute(validInput);

      expect(result.isSuccess).toBe(true);
    });
  });

  describe("error handling", () => {
    it("should not dispatch events when save fails", async () => {
      vi.mocked(mockRepo.create).mockResolvedValue(
        Result.fail("Database error")
      );

      await sut.execute(validInput);

      expect(mockEventDispatcher.dispatchAll).not.toHaveBeenCalled();
    });
  });
});
```

### Naming Convention

BDD pattern: `"should [action] when [condition]"`

- `should create user when email is unique`
- `should fail when password is too short`
- `should emit UserCreated event on success`

## Doc Writer

Maintains documentation and keeps it in sync with code changes.

### When to Use

- After implementing features
- When documentation is outdated
- Adding new patterns

### Documentation Files

| File | Purpose | Update When |
|------|---------|-------------|
| `CLAUDE.md` | Development patterns | New patterns, changed APIs |
| `README.md` | Project overview | New features, setup changes |
| `packages/*/README.md` | Package docs | Package changes |
| `CHANGELOG.md` | Version history | Releases |

### Process

1. **Analyze changes** - What changed? New feature, refactor, fix?
2. **Find affected docs** - Which files reference changed code?
3. **Audit accuracy** - Do examples match implementation?
4. **Update documentation** - Keep concise and accurate

### Output Format

```markdown
## Documentation Updates

### CLAUDE.md

**Section:** Domain Events
**Type:** Updated
**Summary:** Added event dispatch pattern example

**Changes:**
- Added dispatchAll example after persistence
- Updated clearEvents usage
- Fixed outdated Result import
```

### Style Guide

- Use imperative mood ("Create user", not "Creates user")
- Keep examples minimal but complete
- No marketing language
- Technical accuracy over readability
- Code blocks with language tags
- Use tables for structured information

## Using Agents with Task Tool

Agents can be invoked via Claude Code's Task tool:

```typescript
// Claude Code automatically selects appropriate agent
// based on task description and available agents
```

## Creating Custom Agents

Agents are Markdown files in `.claude/agents/`:

```markdown
---
name: my-agent
description: What this agent does
when_to_use: When to invoke this agent
tools:
  - Read
  - Glob
  - Grep
---

# My Agent

You are a specialized assistant for [purpose].

## Process

1. Step one
2. Step two

## Output Format

Expected output structure...
```

### Agent Configuration

| Field | Description |
|-------|-------------|
| `name` | Agent identifier |
| `description` | What the agent does |
| `when_to_use` | Triggering conditions |
| `tools` | Available tools (Read, Glob, Grep, Write, Edit) |

## Best Practices

1. **Feature Architect first** - Plan before implementing
2. **Code Reviewer before commit** - Catch issues early
3. **Test Writer after implementation** - Ensure coverage
4. **Doc Writer after merge** - Keep docs current

## Next Steps

- [AI Skills](/docs/ai/skills)
- [Claude Code Setup](/docs/ai/claude-code)
- [Testing Guide](/docs/guides/testing)
